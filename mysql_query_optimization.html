<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Mysql Query Optimization</title>
    <meta name="description" content="Mysql Query Optimization">
    <meta name="author" content="Stuart Ingram">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="reveal/css/reveal.min.css">
    <link rel="stylesheet" href="reveal/css/theme/default.css" id="theme">
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="reveal/lib/css/zenburn.css">
    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="reveal/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>
    <!--[if lt IE 9]>
	<script src="reveal/lib/js/html5shiv.js"></script>
	<![endif]-->
           <STYLE type="text/css">
.red  {color:#CC9393;}
.green {color:#efef8f;}

.reveal pre code {
    font-size: 15px;
 }

           </STYLE>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

	<section>
	  <h1>Mysql</h1>
	  <h3>Query Optimization</h3>
	  <h4>Mysql 5.1+ & InnoDB</h4>
	  <p>
	    <small>Created by S Ingram / <a href="http://twitter.com/arethoseclams">@arethoseclams</a></small>
	  </p>
	  <p>
	    <small><a href="http://github.com/singram">http://github.com/singram</a></small>
	  </p>
	</section>
        <section>
          <h2>What this talk is</h2>
          <ul style="list-style: none;">
            <li class="fragment"><span class="red">&#10008;</span> Optimizing database load </li>
            <li class="fragment"><span class="red">&#10008;</span> Bad query
            identification</li>
            <li class="fragment"><span class="green">&#10004;</span> Optimizing a single query</li>
          </ul>
        </section>

        <section>
          <h2>Sorry</h2>
          <p><b>There is no silver bullet</b></p>
        </section>

        <section>
          <h2>#1 Rule</h2>
        </section>
        <section>
          <h2>Don't Guess!!</h2>
          <aside class="notes">
              You can't improve something if you don't know how it behaved previously            </aside>
          <h3 class="fragment">Measure</h3>
        </section>
        <section>
          <h2>#2 Rule</h2>
        </section>
        <section>
          <h2>Understand the data</h2>
          <aside class="notes">If you don't understand the data you are operating on
              you can't effectively optimize your query.</aside>
          <ul class="fragment">
            <li>Application Usage</li>
	    <li>Data Characteristics</li>
          </ul>
        </section>

        <section>
          <h2>Beware</h2>
          <ul>
            <li>Timing is important but not the only metric</li>
            <li class="fragment">Query cache</li>
            <ul class="fragment">
              <li>Turn off <br>
                <small>(may actually be better for some workloads)</small></li>
              <li>SQL_NO_CACHE<br>
                <small><code class="sql">SELECT SQL_NO_CACHE foo FROM bar WHERE id = 1;</code></small></li>
            </ul>
            <li class="fragment">Buffer pool</li>
            <aside class="notes">Cache is invalidated if data in a table changes.Initial IO hit as data is read from
              disk to buffer pool memory</aside>
          </ul>
        </section>

        <section>
          <h2>Typical investigation</h2>
          <ul>
            <li>Indexes</li>
            <li class="fragment">Query structure</li>
            <li class="fragment">Data types</li>
            <li class="fragment">Schema structure</li>
          </ul>
        </section>


        <section>
          <h2>Indexes make things faster</h2>
          <ul>
            <li>So lets index everything right?!</li>
            <li>AKA The index shotgun</li>
          </ul>
        </section>

        <section>
          <h2>(BOOM!)</h2>
	    <pre><code class="sql" data-trim >CREATE TABLE `fakenames_shotgun` (
  `id`            BIGINT(20)   NOT NULL AUTO_INCREMENT,
  `Gender`        VARCHAR(100) NOT NULL,
  `GivenName`     VARCHAR(100) NOT NULL,
  `MiddleInitial` VARCHAR(100) NOT NULL,
  `Surname`       VARCHAR(100) NOT NULL,
  PRIMARY KEY (`id`),
  INDEX (`Gender`),
  INDEX (`GivenName`),
  INDEX (`MiddleInitial`),
  INDEX (`Surname`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
        </section>

        <section>
          <h2>So why is this bad?</h2>
          <ul>
            <li>Redundancy</li>
	    <li class="fragment">Write cost</li>
	    <li class="fragment">Storage cost</li>
	    <li class="fragment">Read cost <small>(QEP generation)</small></li>
            <li class="fragment">Indexes not intelligently applied<br>
              No covering or compound indexes</li>
          </ul>
        </section>

        <section>
          <h2>Index Types 101</h2>
          <ul>
            <li>Primary index</li>
            <li>Secondary indexes</li>
            <ul class="fragment">
              <li>Unique  <small class="fragment">Contraints</small>
              </li>
              <li>Index</li>
            </ul>
          </ul>
        </section>

        <section>
          <h2>Index Cardinality</h2>
          <ul style="list-style: none;">
            <li><span class="green">&#10004;</span> High - <code>created_at</code></li>
            <li><span class="red">&#10008;</span> Low  - <code>gender</code></li>
          </ul>
        </section>

        <section>
          <h2>B-Trees - CS 101 flashback</h2>
          <ul>
            <li>Data sorted in blocks</li>
            <li>O(<i>log n</i>) search, seqential access, insert and
            delete</li>
            <li>Optimized for systems that require IO on large data sets.
          </ul>
<!--
In InnoDB, the table itself is a B-Tree with a PRIMARY KEY as a B-Tree
          key. This is what called a "clustered index" or
          "index-organized table". In this case, all other fields are
          stored as a B-Tree value.

In computer science, a B-tree is a tree data structure that keeps data --
  --sorted and allows searches, sequential access, insertions, and --
  --deletions in logarithmic time. The B-tree is a generalization of a --
  --binary search tree in that a node can have more than two children. --
  --(Comer 1979, p. 123) Unlike self-balancing binary search trees, --
  --the B-tree is optimized for systems that read and write large --
  --blocks of data. It is commonly used in databases and filesystems.
-->
        </section>

        <section>
          <h2>Primary key selection</h2>
          <ul>
            <li>Indexes are clustered in a B+Tree</li>
            <li class="fragment">Primary indexes contain data</li>
            <li class="fragment">Sequential vs Random (GUID) vs None</li>
            <ul class="fragment">
              <li>GOOD comments (POST_ID,COMMENT_ID)</li>
              <li>BAD sha1(comment_text)</li>
            </ul>
            <li class="fragment">Secondary indexes postfixed with primary key value</li>
            <ul class="fragment">
              <li>KEY(x) -> KEY(x,id) internally</li>
              <li class="fragment">PK Size is important for secondary keys</li>
            </ul>
          </ul>
        </section>

        <section>
          <section>
            <h2>Sample data</h2>
            <ul>
              <li><a href="http://www.wunderground.com/history/airport/PITT/2007/1/1/CustomHistory.html?dayend=31&monthend=12&yearend=2007&req_city=NA&req_state=NA&req_statename=NA">Weather
                  underground</a></li>
              <li><a href="http://www.fakenamegenerator.com/order.php">FakeNameGenerator.com</a><br><small>1M
              record dump available (schema below)</small></li>
            </ul>
          </section>
          <section>
	    <pre><code class="sql" data-trim >DROP TABLE `fakenames_full`;
CREATE TABLE `fakenames_full` (
  `id`              BIGINT(20) NOT NULL AUTO_INCREMENT,
  `Gender`          VARCHAR(100) NOT NULL,
  `GivenName`       VARCHAR(100) NOT NULL,
  `MiddleInitial`   VARCHAR(100) NOT NULL,
  `Surname`         VARCHAR(100) NOT NULL,
  `StreetAddress`   VARCHAR(100) NOT NULL,
  `City`            VARCHAR(100) NOT NULL,
  `State`           VARCHAR(100) NOT NULL,
  `ZipCode`         VARCHAR(100) NOT NULL,
  `Country`         VARCHAR(100) NOT NULL,
  `EmailAddress`    VARCHAR(100) NOT NULL,
  `Username`        VARCHAR(100) NOT NULL,
  `Password`        VARCHAR(100) NOT NULL,
  `TelephoneNumber` VARCHAR(100) NOT NULL,
  `MothersMaiden`   VARCHAR(100) NOT NULL,
  `dob`             DATETIME DEFAULT 0,
  `CCType`          VARCHAR(100) NOT NULL,
  `CCNumber`        VARCHAR(100) NOT NULL,
  `CVV2`            VARCHAR(100) NOT NULL,
  `CCExpires`       VARCHAR(100) NOT NULL,
  `NationalID`      VARCHAR(100) NOT NULL DEFAULT '',
  `UPS`             VARCHAR(100) NOT NULL,
  `Occupation`      VARCHAR(100) NOT NULL,
  `Company`         VARCHAR(100) NOT NULL,
  `Vehicle`         VARCHAR(100) NOT NULL,
  `Domain`          VARCHAR(100) NOT NULL,
  `BloodType`       VARCHAR(100) NOT NULL,
  `Pounds`          VARCHAR(100) NOT NULL,
  `Kilograms`       VARCHAR(100) NOT NULL,
  `FeetInches`      VARCHAR(100) NOT NULL,
  `Centimeters`     VARCHAR(100) NOT NULL,
  `GUID`            VARCHAR(100) NOT NULL,
  `Latitude`        VARCHAR(100) NOT NULL,
  `Longitude`       VARCHAR(100) NOT NULL,
  `created_at`     TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

load data infile '/path_to/FakeNameGenerator.com.csv' into table fakenames_full fields terminated by ',' lines terminated by '\n';
Query OK, 1000000 rows affected, 65535 warnings (24.39 sec)
Records: 1000000  Deleted: 0  Skipped: 0  Warnings: 1000000</code></pre>
<p align="left">This fixes dates.  This is your friend</p>
<pre><code class="sql" data-trim >sed  -i "s|,\([0-9]\+\)/\([0-9]\+\)/\([0-9]\+\),|,\3-\1-\2,|g" FileNameGenerator.com.csv</code></pre>
          </section>
          <section>
            <h3>IMDB References</h3>
            <p align="left">
            <a href="http://www.imdb.com/interfaces">IMDB Data sources and license</a><br>
            <a href="ftp://ftp.fu-berlin.de/pub/misc/movies/database/">IMDB Data</a><br>
            <a href="http://web.eecs.umich.edu/~aprakash/eecs282/lectures/12-parsing-input.pdf">Paper 1</a><br>
            <a href="http://had.co.nz/data/movies/description.pdf">Paper
            2</a>
            </p>
          </section>
        </section>

        <section>
          <h2>1st Tool for query analysis</h2>
          <p>EXPLAIN</p>
	  <pre><code class="sql" data-trim >singram, presentation>EXPLAIN SELECT * FROM fakenames;
+----+-------------+-----------+------+---------------+------+---------+------+-------+-------+
| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows  | Extra |
+----+-------------+-----------+------+---------------+------+---------+------+-------+-------+
|  1 | SIMPLE      | fakenames | ALL  | NULL          | NULL | NULL    | NULL | 50071 |       |
+----+-------------+-----------+------+---------------+------+---------+------+-------+-------+
1 row in set (0.00 sec)</code></pre>
          <p class="fragment"><small>(Works for UPDATE and DELETE statements in 5.6)</small></p>
        </section>

        <section>
          <h2>Understanding Explain</h2>
          <ul>
            <li>Stats are estimates.</li>
            <li>Does not consider triggers/proceedures</li>
            <li>Temporary - (in memory/disk)</li>
            <li>Filesort - (in memory/disk)</li>
            <li>Subqueries are executes to so that out loops are
            optimized appropriately</li>
          </ul>
        </section>

        <section>
          <h3>Types of query</h3>
          <table>
            <tr>
              <td>all</td>
              <td>full table scan</td>
            </tr>
            <tr>
              <td>index</td>
              <td>index scan</td>
            </tr>
            <tr>
              <td>range</td>
              <td>limited index scan</td>
            </tr>
            <tr>
              <td>ref</td>
              <td>one or more match based on index</td>
            </tr>
            <tr>
              <td>eq_ref</td>
              <td>single value match based on index</td>
            </tr>
            <tr>
              <td>const</td>
              <td></td>
            </tr>
            <tr>
              <td>NULL</td>
              <td>information from index.  No table access</td>
            </tr>
          </table>
        </section>

        <section>
          <h2>Basic index</h2>
	  <pre><code class="sql" data-trim >ingram, presentation> EXPLAIN  SELECT COUNT(*) FROM fakenames_full WHERE dob = '1980-01-01 00:00:00';
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | fakenames_full | ALL  | NULL          | NULL | NULL    | NULL | 999757 | Using where |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
1 row in set (0.01 sec)</code></pre>
	  <pre  class="fragment"><code class="sql" data-trim >singram, presentation> ALTER TABLE fakenames_full ADD INDEX (dob);
Query OK, 0 rows affected (4.43 sec)
Records: 0  Duplicates: 0  Warnings: 0

singram, presentation> EXPLAIN SELECT COUNT(*) FROM fakenames_full WHERE dob = '1940-01-01 00:00:00';
+----+-------------+----------------+------+---------------+------+---------+-------+------+--------------------------+
| id | select_type | table          | type | possible_keys | key  | key_len | ref   | rows | Extra                    |
+----+-------------+----------------+------+---------------+------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | fakenames_full | ref  | dob           | dob  | 9       | const |   43 | Using where; Using index |
+----+-------------+----------------+------+---------------+------+---------+-------+------+--------------------------+
1 row in set (0.00 sec)</code></pre>
        </section>

        <section>
          <h2>Functions and indexes</h2>
          <p align="left">How does the index know the result of a function
          performed upon its values at query time?</p>
          <div  class="fragment">
            <h3>Bad</h3>
	    <pre><code class="sql" data-trim >SELECT COUNT(*) FROM
fakenames_full WHERE YEAR(dob)='1980';</code></pre>
          </div>
          <div class="fragment">
            <h3 class="green">Good</h3>
	    <pre><code class="sql" data-trim >SELECT COUNT(*) FROM fakenames_full
WHERE dob BETWEEN '1980-01-01 00:00:00' AND '1980-12-31 23:59:59';</code></pre>
	    <pre><code class="sql" data-trim >ALTER TABLE fakenames_full ADD dob_year SMALLINT AFTER dob;
UPDATE fakenames_full SET dob_year = YEAR(dob);
ALTER TABLE fakenames_full ADD INDEX (dob_year);
SELECT COUNT(*) FROM fakenames_full WHERE dob_year = 1980;</code></pre>
            <aside class="notes">
              Index adding after data.
              Data redundancy adds complexity.
              Trigger enforcement
            </aside
          </div>
        </section>

        <section>
          <h2>Strings and indexes</h2>
          <h3>Bad</h3>
	  <pre><code class="sql" data-trim >SELECT name FROM people WHERE name LIKE '%x%';</code></pre>
          <h3>Good</h3>
	  <pre><code class="sql" data-trim >SELECT name FROM people WHERE name LIKE 'x%';</code></pre>
        </section>

        <section>
          <h2>Compound Index</h2>
          <ul class="fragment">
            <li>Ordering is important</li>
            <li>Redundancy</li>
            <ul class="fragment">
              <li>INDEX(A,B)</li>
              <li>INDEX(A) <span class="red">&#8680; Redundant</span></li>
              <li>INDEX(B)</li>
              <li>INDEX(B,id) <span class="red">&#8680; Redundant</span></li>
            </ul>
          </ul>
        </section>
        <section>
          <h2>Index (A,B,C)</h2>
        </section>
        <section>
          <h2><span class="green">&#10004;</span>Will use</h2>
          <ul>
            <li>A>5</li>
            <li>A=5 AND B>7</li>
            <li>A=5 AND B=7 AND C=8</li>
          </ul>
        </section>
        <section>
          <h2><span class="red">&#10008;</span>Wont use</h2>
          <ul>
            <li>B>7</li>
            <li>B=7 AND C=8</li>
          </ul>
        </section>
        <section>
          <h2><span class="green">&#10004;</span><span class="red">&#10008;</span>Partially use</h2>
          <ul>
            <li>A>5 AND B=7</li>
            <li>A=5 AND B>7 AND C=8</li>
          </ul>
          <p class="fragment">Compound indexes utilized up to first range operation</p>
        </section>
        <section>
          <h2>Range operation workaround</h2>
          <ul class="fragment">
            <li>A=5 AND B BETWEEN 1 AND 3 AND C>8</li>
            <li class="fragment">A=5 AND B IN (1,2,3) AND C>8</li>
          </ul>
          <pre class="fragment"><code class="sql" data-trim >ALTER TABLE fakenames_full ADD INDEX (state,zipcode);</code></pre>
          <pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT * FROM fakenames_full WHERE zipcode='2540';
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | fakenames_full | ALL  | NULL          | NULL | NULL    | NULL | 996492 | Using where |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+</code></pre>
        </section>
        <section>
          <pre><code class="sql" data-trim >EXPLAIN SELECT * FROM fakenames_full WHERE state= 'NSW' AND zipcode='2540';
+----+-------------+----------------+------+---------------+-------+---------+-------------+------+-------------+
| id | select_type | table          | type | possible_keys | key   | key_len | ref         | rows | Extra       |
+----+-------------+----------------+------+---------------+-------+---------+-------------+------+-------------+
|  1 | SIMPLE      | fakenames_full | ref  | State         | State | 604     | const,const | 3676 | Using where |
+----+-------------+----------------+------+---------------+-------+---------+-------------+------+-------------+</code></pre>

          <pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT * FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra       |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+</code></pre>
<p class="fragment">Useful for when range is small enough to enumerate</p>
        </section>

        <section>
          <h2>Covering Index</h2>
          <p class="fragment">Query can be 100% satisfied by index data</p>

<pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT * FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra       |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+</code></pre>

<pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT state FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra                    |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where; Using index |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+</code></pre>
<pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT id FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra                    |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where; Using index |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+</code></pre>
          <p class="fragment">Potentially removes pk lookup for secondary indexes</p>
        </section>
        <section>
          <h2>Sort</h2>
          <ul>
            <li>No index &#8680; Filesort (memory/disk)</li>
            <li>VARCHAR size selection important</li>
          </ul>
        </section>
        <section>
          <h2>Sort - Compound key</h2>
          <ul>
            <li>No index &#8680; Filesort (memory/disk)</li>
            <li>Similar constraints to general compound key usage</li>
            <li>You canâ€™t sort in different order by 2 columns</li>
          </ul>
        </section>
        <section>
          <h2>Index (A,B,C)</h2>
        </section>
        <section>
          <h2><span class="green">&#10004;</span>Will use</h2>
          <ul>
            <li>ORDER BY A</li>
            <li>A=7 ORDER BY B</li>
            <li>ORDER BY A DESC, B DESC</li>
            <li>A>7 ORDER BY A</li>
          </ul>
        </section>
        <section>
          <h2><span class="red">&#10008;</span>Wont use</h2>
          <ul>
            <li>ORDER BY B</li>
            <li>A>7 ORDER BY B</li>
            <li>A IN(1,2) ORDER BY B</li>
            <li>ORDER BY A ASC, B DESC</li>
          </ul>
        </section>

        <section>
          <h2>Group By</h2>
        </section>

        <section>
          <h2>Index selection</h2>
          <ul>
            <li>Don't mess with the optimizer</li>
            <li>It's *usually* right</li>
            <li>No index - Sometimes it's more trouble to access index than do
              full table scan</li>
          </ul>
        </section>
        <section>
          <h2>Left joins vs Inner join</h2>
        </section>
        <section>
          <h2>UNION trick</h2>
        </section>
        <section>

          <h2>Aggregation tables.</h2>
          Large reports
          Avoid cache stampeed

        </section>
        <section>

          <h2>Andrie's rules</h2>
          <ul>
            <li>Remember the rules</li>
            <li>Understand the rules</li>
            <li>Break the rules when necessary</li>
            <li class="fragment">(Except Stuarts #1 and #2)</li>
          </ul>
        </section>


	<section>
	  <h1>THE END</h1>
	  <h3>Thank you</h3>
	</section>

      </div>

    </div>

    <script src="reveal/lib/js/head.min.js"></script>
    <script src="reveal/js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,
      width: 1200,
      theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

      // Optional libraries used to extend on reveal.js
      dependencies: [
      { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
      // { src: 'reveal/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
      // { src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
      ]
      });

    </script>

  </body>
</html>
