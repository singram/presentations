<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <title>Mysql Query Optimization</title>
    <meta name="description" content="Mysql Query Optimization">
    <meta name="author" content="Stuart Ingram">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="reveal/css/reveal.min.css">
    <link rel="stylesheet" href="reveal/css/theme/default.css" id="theme">
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="reveal/lib/css/zenburn.css">
    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="reveal/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>
    <!--[if lt IE 9]>
    <script src="reveal/lib/js/html5shiv.js"></script>
    <![endif]-->
       <STYLE type="text/css">
         .red   { color:#CC9393; }
         .green { color:#efef8f; }
         .reveal pre code { font-size: 15px; }
       </STYLE>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

	<section>
	  <h1>Mysql</h1>
	  <h3>Query Optimization</h3>
	  <h4>Mysql 5.1+ & InnoDB</h4>
	  <p>
	    <small>Created by S Ingram / <a href="http://twitter.com/arethoseclams">@arethoseclams</a></small>
	  </p>
	  <p>
	    <small><a href="http://github.com/singram">http://github.com/singram</a></small>
	  </p>
	</section>

        <section>
          <h2>What this talk is</h2>
          <ul style="list-style: none;">
            <li class="fragment"><span class="red">&#10008;</span> Optimizing database load </li>
            <li class="fragment"><span class="red">&#10008;</span> Bad query
            identification</li>
            <li class="fragment"><span class="green">&#10004;</span> Optimizing a single query</li>
          </ul>
        </section>

        <section>
          <h2>Sorry</h2>
          <p><b>There is no silver bullet</b></p>
        </section>

        <section>
          <h2>#1 Rule</h2>
          <h2>Don't Guess!!</h2>
          <aside class="notes">
              You can't improve something if you don't know how it behaved previously
          </aside>
          <h3 class="fragment">Measure</h3>
        </section>

        <section>
          <h2>#2 Rule</h2>
          <h2>Understand the data</h2>
          <aside class="notes">If you don't understand the data you are operating on
              you can't effectively optimize your query.</aside>
          <ul class="fragment">
            <li>Application Usage</li>
	    <li>Data Characteristics</li>
          </ul>
        </section>

        <section>
          <h2>Beware</h2>
          <ul>
            <li>Timing is important but not the only metric</li>
            <li class="fragment">Query cache</li>
            <ul class="fragment">
              <li>Turn off <br>
                <small><code class="sql">SET query_cache_type = OFF;</code></small><br>
                <small>(may actually be better for some workloads)</small></li>
              <li>SQL_NO_CACHE<br>
                <small><code class="sql">SELECT SQL_NO_CACHE foo FROM bar WHERE id = 1;</code></small></li>
            </ul>
            <li class="fragment">Buffer pool</li>
            <aside class="notes">Cache is invalidated if data in a table changes.Initial IO hit as data is read from
              disk to buffer pool memory</aside>
          </ul>
        </section>

        <section>
          <h2>Typical investigation</h2>
          <ul>
            <li>Indexes</li>
            <li class="fragment">Query structure</li>
            <li class="fragment">Data types</li>
            <li class="fragment">Schema structure</li>
          </ul>
        </section>

        <section>
          <h2>Indexes make things faster</h2>
          <ul>
            <li>So lets index everything right?!</li>
            <li>AKA The index shotgun</li>
          </ul>
        </section>

        <section>
          <h2>BOOM!</h2>
	    <pre><code class="sql" data-trim >CREATE TABLE `fakenames_shotgun` (
  `id`            BIGINT(20)   NOT NULL AUTO_INCREMENT,
  `Gender`        VARCHAR(100) NOT NULL,
  `GivenName`     VARCHAR(100) NOT NULL,
  `MiddleInitial` VARCHAR(100) NOT NULL,
  `Surname`       VARCHAR(100) NOT NULL,
  PRIMARY KEY (`id`),
  INDEX (`Gender`),
  INDEX (`GivenName`),
  INDEX (`MiddleInitial`),
  INDEX (`Surname`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
        </section>

        <section>
          <h2>So why is this bad?</h2>
          <ul>
            <li>Redundancy</li>
	    <li class="fragment">Write cost</li>
	    <li class="fragment">Storage cost</li>
	    <li class="fragment">Read cost <small>(QEP generation)</small></li>
            <li class="fragment">Indexes not intelligently applied<br>
              No covering or compound indexes</li>
          </ul>
        </section>

        <section>
          <h2>Index Types 101</h2>
          <ul>
            <li>Primary index</li>
            <li>Secondary indexes</li>
            <ul class="fragment">
              <li>Unique  <small class="fragment">Contraints</small>
              </li>
              <li>Index</li>
            </ul>
          </ul>
        </section>

        <section>
          <h2>Index Cardinality</h2>
          <ul style="list-style: none;">
            <li><span class="green">&#10004;</span> High - <code>created_at</code></li>
            <li><span class="red">&#10008;</span> Low  - <code>gender</code></li>
          </ul>
          <p><small>The goal of an index is to increase selectivity across a
          set of data</small></p>
        </section>

        <section>
          <h2>CS101 flashback - B-Trees</h2>
          <ul>
            <li>Similar to binary tree</li>
            <li>Data sorted in blocks</li>
            <li>O(<i>log n</i>) search, seqential access, insert and
            delete</li>
            <li>Optimized for systems that require IO on large data sets.
          </ul>
<!--
In InnoDB, the table itself is a B-Tree with a PRIMARY KEY as a B-Tree
          key. This is what called a "clustered index" or
          "index-organized table". In this case, all other fields are
          stored as a B-Tree value.

In computer science, a B-tree is a tree data structure that keeps data --
  --sorted and allows searches, sequential access, insertions, and --
  --deletions in logarithmic time. The B-tree is a generalization of a --
  --binary search tree in that a node can have more than two children. --
  --(Comer 1979, p. 123) Unlike self-balancing binary search trees, --
  --the B-tree is optimized for systems that read and write large --
  --blocks of data. It is commonly used in databases and filesystems.
-->
        </section>

        <section>
          <h2>Primary key selection</h2>
          <ul>
            <li>Indexes are clustered in a B+Tree</li>
            <li class="fragment">Primary indexes contain data</li>
            <li class="fragment">PK Selection - Sequential vs Random (GUID) vs None</li>
            <ul class="fragment">
              <li>GOOD sequential ids</li>
              <li>GOOD comments (POST_ID,COMMENT_ID)</li>
              <li>BAD sha1(comment_text)</li>
            </ul>
            <li class="fragment">Secondary indexes postfixed with primary key value</li>
            <ul class="fragment">
              <li>KEY(x) -> KEY(x,id) internally</li>
              <li class="fragment">PK Size is important for secondary keys</li>
            </ul>
          </ul>
        </section>

        <section>
          <section>
            <h2>Sample data</h2>
            <ul>
              <li><a href="http://www.fakenamegenerator.com/order.php">FakeNameGenerator.com</a><br><small>1M
              record dump available (schema below)</small></li>
              <li><a href="http://www.wunderground.com/history/airport/PITT/2007/1/1/CustomHistory.html?dayend=31&monthend=12&yearend=2007&req_city=NA&req_state=NA&req_statename=NA">Weather
                  underground</a></li>
              <li><a href="ftp://ftp.fu-berlin.de/pub/misc/movies/database/">IMDB Data</a></li>
            </ul>
          </section>
          <section>
	    <pre><code class="sql" data-trim >DROP TABLE `fakenames_full`;
CREATE TABLE `fakenames_full` (
  `id`              BIGINT(20) NOT NULL AUTO_INCREMENT,
  `Gender`          VARCHAR(100) NOT NULL,
  `GivenName`       VARCHAR(100) NOT NULL,
  `MiddleInitial`   VARCHAR(100) NOT NULL,
  `Surname`         VARCHAR(100) NOT NULL,
  `StreetAddress`   VARCHAR(100) NOT NULL,
  `City`            VARCHAR(100) NOT NULL,
  `State`           VARCHAR(100) NOT NULL,
  `ZipCode`         VARCHAR(100) NOT NULL,
  `Country`         VARCHAR(100) NOT NULL,
  `EmailAddress`    VARCHAR(100) NOT NULL,
  `Username`        VARCHAR(100) NOT NULL,
  `Password`        VARCHAR(100) NOT NULL,
  `TelephoneNumber` VARCHAR(100) NOT NULL,
  `MothersMaiden`   VARCHAR(100) NOT NULL,
  `dob`             DATETIME DEFAULT 0,
  `CCType`          VARCHAR(100) NOT NULL,
  `CCNumber`        VARCHAR(100) NOT NULL,
  `CVV2`            VARCHAR(100) NOT NULL,
  `CCExpires`       VARCHAR(100) NOT NULL,
  `NationalID`      VARCHAR(100) NOT NULL DEFAULT '',
  `UPS`             VARCHAR(100) NOT NULL,
  `Occupation`      VARCHAR(100) NOT NULL,
  `Company`         VARCHAR(100) NOT NULL,
  `Vehicle`         VARCHAR(100) NOT NULL,
  `Domain`          VARCHAR(100) NOT NULL,
  `BloodType`       VARCHAR(100) NOT NULL,
  `Pounds`          VARCHAR(100) NOT NULL,
  `Kilograms`       VARCHAR(100) NOT NULL,
  `FeetInches`      VARCHAR(100) NOT NULL,
  `Centimeters`     VARCHAR(100) NOT NULL,
  `GUID`            VARCHAR(100) NOT NULL,
  `Latitude`        VARCHAR(100) NOT NULL,
  `Longitude`       VARCHAR(100) NOT NULL,
  `created_at`     TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

load data infile '/path_to/FakeNameGenerator.com.csv' into table fakenames_full fields terminated by ',' lines terminated by '\n';
Query OK, 1000000 rows affected, 65535 warnings (24.39 sec)
Records: 1000000  Deleted: 0  Skipped: 0  Warnings: 1000000</code></pre>
<p align="left">This fixes dates.  This is your friend</p>
<pre><code class="sql" data-trim >sed  -i "s|,\([0-9]\+\)/\([0-9]\+\)/\([0-9]\+\),|,\3-\1-\2,|g" FileNameGenerator.com.csv</code></pre>
          </section>

          <section>
            <h3>IMDB References</h3>
            <p align="left">
            <a href="http://www.imdb.com/interfaces">IMDB Data sources and license</a><br>
            <a href="ftp://ftp.fu-berlin.de/pub/misc/movies/database/">IMDB Data</a><br>
            <a href="http://web.eecs.umich.edu/~aprakash/eecs282/lectures/12-parsing-input.pdf">Paper 1</a><br>
            <a href="http://had.co.nz/data/movies/description.pdf">Paper
            2</a>
            </p>
          </section>
        </section>

        <section>
          <h2>1st Tool for query analysis</h2>
          <h3>'EXPLAIN'</h3>
        </section>

        <section>
          <h3>Explain Output</h3>
	  <pre><code class="sql" data-trim >singram, presentation>EXPLAIN SELECT * FROM fakenames;
+----+-------------+-----------+------+---------------+------+---------+------+-------+-------+
| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows  | Extra |
+----+-------------+-----------+------+---------------+------+---------+------+-------+-------+
|  1 | SIMPLE      | fakenames | ALL  | NULL          | NULL | NULL    | NULL | 50071 |       |
+----+-------------+-----------+------+---------------+------+---------+------+-------+-------+
1 row in set (0.00 sec)</code></pre>
          <table>
            <tbody>
              <tr><td >id</td><td>The SELECT identifier</td></tr>
              <tr><td >select_type</td><td>The SELECT type</td></tr>
              <tr><td >table</td><td>The table for the output row</td></tr>
              <tr><td class="green">type</td><td>The join type</td></tr>
              <tr><td >possible_keys</td><td>The possible indexes to choose</td></tr>
              <tr><td >key</td><td>The index actually chosen</td></tr>
              <tr><td >key_len</td><td>The length of the chosen key</td></tr>
              <tr><td >ref</td><td>The columns compared to the index</td></tr>
              <tr><td class="green" >rows</td><td>Estimate of rows to be examined</td></tr>
              <tr><td class="green">Extra</td><td>Additional information</td></tr>
            </tbody>
          </table>
            <aside class="notes">
              Works for UPDATE AND DELETED statements in 5.6
            </aside>
        </section>

        <section>
          <h2>Understanding Explain</h2>
          <ul>
            <li>Statistics are estimates.<br>
              <pre><code class="sql" data-trim >ANALYZE TABLE mydatabase.sometable</code></pre>
            </li>
            <li class="fragment">Does not consider triggers/proceedures</li>
            <li class="fragment">Subqueries are executed too so that out loops are optimized appropriately</li>
          </ul>
        </section>

        <section>
          <h3>Join types</h3>
          <table>
            <tr><td class="red">all</td><td>full table scan</td></tr>
            <tr><td>index</td><td>index scan</td></tr>
            <tr><td>range</td><td>limited index scan</td></tr>
            <tr><td>ref</td><td>one or more match based on index dependent on previous table reads</td></tr>
            <tr><td class="green">eq_ref</td><td>single value match based on index dependent on previous table reads</td></tr>
            <tr><td class="green">const</td><td>single value match for entire query based on index</td>
            </tr>
          </table>
        </section>

        <section>
          <h3>Extra field options of note</h3>
          <table>
            <tr class="fragment"><td class="red">Using filesort</td><td>MySQL must do an extra pass to find out how to retrieve the rows in sorted order</td></tr>
            <tr class="fragment"><td class="red">Using temporary</td><td>To resolve the query, MySQL needs to create a temporary table to hold the result. This typically happens if the query contains GROUP BY and ORDER BY clauses that list columns differently.</td></tr>
            <tr class="fragment"><td>Using where</td><td>Where clause used to reduce result set from join.</td></tr>
            <tr class="fragment"><td class="green">Using index</td><td>The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row</td></tr>
            <tr class="fragment"><td class="green">Using index for group-by</td><td>one or more match based on index dependent on previous table reads</td></tr>
            </tr>
          </table>
        </section>

        <section>
          <h2>Basic index</h2>
	  <pre><code class="sql" data-trim >ingram, presentation> EXPLAIN SELECT givenname FROM fakenames_full WHERE dob = '1980-01-01 00:00:00';
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | fakenames_full | ALL  | NULL          | NULL | NULL    | NULL | 999757 | Using where |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
1 row in set (0.01 sec)</code></pre>
	  <pre  class="fragment"><code class="sql" data-trim >singram, presentation> ALTER TABLE fakenames_full ADD INDEX (dob);
Query OK, 0 rows affected (4.43 sec)
Records: 0  Duplicates: 0  Warnings: 0

singram, presentation> EXPLAIN SELECT givenname FROM fakenames_full WHERE dob = '1940-01-01 00:00:00';
+----+-------------+----------------+------+---------------+------+---------+-------+------+-------------+
| id | select_type | table          | type | possible_keys | key  | key_len | ref   | rows | Extra       |
+----+-------------+----------------+------+---------------+------+---------+-------+------+-------------+
|  1 | SIMPLE      | fakenames_full | ref  | dob           | dob  | 9       | const |   43 | Using where |
+----+-------------+----------------+------+---------------+------+---------+-------+------+-------------+
1 row in set (0.00 sec)</code></pre>
        </section>

        <section>
          <h2>Functions and indexes</h2>
          <p align="left">How does the index know the result of a function
          performed upon its values at query time?</p>
          <div  class="fragment">
            <h3>Bad</h3>
	    <pre><code class="sql" data-trim >SELECT streetaddress FROM
fakenames_full WHERE YEAR(dob)='1980';</code></pre>
          </div>
          <div class="fragment">
            <h3 class="green">Good</h3>
	    <pre><code class="sql" data-trim >SELECT streetaddress FROM fakenames_full
WHERE dob BETWEEN '1980-01-01 00:00:00' AND '1980-12-31 23:59:59';</code></pre>
          </div>
          <div class="fragment">
            <h3 >Ugly</h3>
	    <pre><code class="sql" data-trim >ALTER TABLE fakenames_full ADD dob_year SMALLINT AFTER dob;
UPDATE      fakenames_full SET dob_year = YEAR(dob);
ALTER TABLE fakenames_full ADD INDEX (dob_year);
SELECT streetaddress FROM fakenames_full WHERE dob_year = 1980;</code></pre>
            <aside class="notes">
              Index added after inserting data if more optimal.
              Data redundancy adds complexity.
              Trigger enforcement can assist avoiding data integrity issues.
            </aside>
          </div>
        </section>

        <section>
          <h2>Functions and indexes (cont.)</h2>
          <h3>Bad</h3>
          <pre><code class="sql" data-trim >root, presentation> EXPLAIN SELECT streetaddress FROM fakenames_full WHERE YEAR(dob)='1980';
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | fakenames_full | ALL  | NULL          | NULL | NULL    | NULL | 999738 | Using where |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
1 row in set (0.00 sec)</code></pre>

          <aside class="notes">
            Good - range, 30000 rows read, using row
          </aside>
        </section>

        <section>
          <h2>Functions and indexes (cont.)</h2>
          <h3>Good</h3>
          <pre><code class="sql" data-trim >root, presentation> EXPLAIN SELECT streetaddress FROM fakenames_full
WHERE dob BETWEEN '1980-01-01 00:00:00' AND '1980-12-31 23:59:59';
+----+-------------+----------------+-------+---------------+------+---------+------+-------+-------------+
| id | select_type | table          | type  | possible_keys | key  | key_len | ref  | rows  | Extra       |
+----+-------------+----------------+-------+---------------+------+---------+------+-------+-------------+
|  1 | SIMPLE      | fakenames_full | range | dob           | dob  | 9       | NULL | 26258 | Using where |
+----+-------------+----------------+-------+---------------+------+---------+------+-------+-------------+
1 row in set (0.01 sec)</code></pre>
          <h3>Ugly</h3>
<pre><code class="sql" data-trim >root, presentation> EXPLAIN SELECT streetaddress FROM fakenames_full WHERE dob_year = 1980;
+----+-------------+----------------+------+---------------+----------+---------+-------+-------+-------------+
| id | select_type | table          | type | possible_keys | key      | key_len | ref   | rows  | Extra       |
+----+-------------+----------------+------+---------------+----------+---------+-------+-------+-------------+
|  1 | SIMPLE      | fakenames_full | ref  | dob_year      | dob_year | 3       | const | 29868 | Using where |
+----+-------------+----------------+------+---------------+----------+---------+-------+-------+-------------+
1 row in set (0.01 sec)</code></pre>
          <aside class="notes">
            Ugly - Query overall is much better.  Index usage is now a
            constant reference, not a range.  Rows are same.  However
            the cost is in the maintenance and risk as well as storage to this approach
          </aside>
        </section>

        <section>
          <h2>Strings and indexes</h2>
	  <pre><code class="sql" data-trim >ALTER TABLE fakenames_full ADD INDEX (surname);</code></pre>
          <div class="fragment">
            <h3>Bad</h3>
	    <pre><code class="sql" data-trim >SELECT givenname FROM fakenames_full WHERE surname LIKE '%brian%';</code></pre>
            <h3>Good</h3>
	    <pre><code class="sql" data-trim >SELECT givenname FROM fakenames_full WHERE surname LIKE 'brian%';</code></pre>
          </div>
        </section>

        <section>
          <h2>Strings and indexes (cont.)</h2>
          <h3>Bad</h3>
	  <pre><code class="sql" data-trim >root, presentation> EXPLAIN SELECT givenname FROM fakenames_full WHERE surname LIKE '%brian%';
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | fakenames_full | ALL  | NULL          | NULL | NULL    | NULL | 999738 | Using where |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
1 row in set (0.00 sec)</code></pre>
          <h3>Good</h3>
	  <pre><code class="sql" data-trim >root, presentation> EXPLAIN SELECT givenname FROM fakenames_full WHERE surname LIKE 'brian%';
+----+-------------+----------------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table          | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+----------------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | fakenames_full | range | Surname       | Surname | 302     | NULL |    1 | Using where |
+----+-------------+----------------+-------+---------------+---------+---------+------+------+-------------+
1 row in set (0.01 sec)</code></pre>
        </section>

        <section>
          <h2>Compound Index</h2>
          <ul class="fragment">
            <li >Ordering is important</li>
            <li class="fragment">Redundancy</li>
            <ul class="fragment">
              <li>INDEX(A,B)</li>
              <li>INDEX(A) <span class="red">&#8680; Redundant</span></li>
              <li>INDEX(B)</li>
              <li>INDEX(B,id) <span class="red">&#8680; Redundant</span></li>
            </ul>
          </ul>
        </section>

        <section>
          <h2>Index (A,B,C)</h2>
        </section>

        <section>
          <h2><span class="green">&#10004;</span>Will use</h2>
          <ul>
            <li>A>5</li>
            <li>A=5 AND B>7</li>
            <li>A=5 AND B=7 AND C=8</li>
          </ul>
        </section>

        <section>
          <h2><span class="red">&#10008;</span>Wont use</h2>
          <ul>
            <li>B>7</li>
            <li>B=7 AND C=8</li>
          </ul>
        </section>

        <section>
          <h2><span class="green">&#10004;</span><span class="red">&#10008;</span>Partially use</h2>
          <ul>
            <li>A>5 AND B=7</li>
            <li>A=5 AND B>7 AND C=8</li>
          </ul>
          <p class="fragment">Compound indexes utilized up to first range operation</p>
        </section>

        <section>
          <h2>Range operation workaround</h2>
          <ul class="fragment">
            <li>A=5 AND B BETWEEN 1 AND 3 AND C>8
              <br><span class="red">&#8680; Index used for only A &amp; B</span></li>
            <li class="fragment">A=5 AND B IN (1,2,3) AND C>8
              <br><span class="green">&#8680; Index used for A, B &amp; C</span></li>
          </ul>
        </section>

        <section>
          <pre><code class="sql" data-trim >ALTER TABLE fakenames_full ADD INDEX (state,zipcode);</code></pre>
          <pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT * FROM fakenames_full WHERE zipcode='2540';
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | fakenames_full | ALL  | NULL          | NULL | NULL    | NULL | 996492 | Using where |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+</code></pre>
          <pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT * FROM fakenames_full WHERE state= 'NSW' AND zipcode='2540';
+----+-------------+----------------+------+---------------+-------+---------+-------------+------+-------------+
| id | select_type | table          | type | possible_keys | key   | key_len | ref         | rows | Extra       |
+----+-------------+----------------+------+---------------+-------+---------+-------------+------+-------------+
|  1 | SIMPLE      | fakenames_full | ref  | State         | State | 604     | const,const | 3676 | Using where |
+----+-------------+----------------+------+---------------+-------+---------+-------------+------+-------------+</code></pre>

          <pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT * FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra       |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+</code></pre>
<p class="fragment">Useful for when range is small enough to enumerate<br>
(Rule#2 - Know your data)</p>
        </section>

        <section>
          <h2>Covering Index</h2>
          <p class="fragment green">Query can be 100% satisfied by index data</p>

<pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT * FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra       |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+</code></pre>

<pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT state FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra                    |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where; Using index |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+</code></pre>
<pre class="fragment"><code class="sql" data-trim >EXPLAIN SELECT id FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra                    |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where; Using index |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+</code></pre>
          <p class="fragment"><small>Potentially removes primary key look-up when using secondary indexes avoiding random access</small></p>
          <aside class="notes">While index is sequential, data access resulting from a query is typically not<aside>
        </section>

        <section>
          <h2>Covering Index - Not all great</h2>
          <h3>Bad</h3>
          <pre><code class="sql" data-trim >root, presentation> EXPLAIN SELECT streetaddress FROM fakenames_full WHERE YEAR(dob)='1980';
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table          | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | fakenames_full | ALL  | NULL          | NULL | NULL    | NULL | 999738 | Using where |
+----+-------------+----------------+------+---------------+------+---------+------+--------+-------------+
1 row in set (0.00 sec)</code></pre>
          <div class="fragment">
            <h3>Not quite as bad</h3>
            <pre><code class="sql" data-trim >root, presentation>root, presentation> EXPLAIN SELECT COUNT(*) FROM fakenames_full WHERE YEAR(dob)='1980';
+----+-------------+----------------+-------+---------------+------+---------+------+--------+--------------------------+
| id | select_type | table          | type  | possible_keys | key  | key_len | ref  | rows   | Extra                    |
+----+-------------+----------------+-------+---------------+------+---------+------+--------+--------------------------+
|  1 | SIMPLE      | fakenames_full | index | NULL          | dob  | 9       | NULL | 999738 | Using where; Using index |
+----+-------------+----------------+-------+---------------+------+---------+------+--------+--------------------------+
1 row in set (0.00 sec)</code></pre>
          </div>
          <aside class="notes">
            Bad - 'Using index' because data is from index, all 1M
            rows still read but from index.
          </aside>
        </section>

        <section>
          <h2>Sort & Group By</h2>
          <ul>
            <li>No index <span class="red">&#8680; Filesort (memory/disk)</span></li>
            <li>Sort operation implied by GROUP BY</li>
            <li>VARCHAR size selection important</li>
            <li>Compound indexes have similar constraints to general compound key usage
              <span class="red fragment"><br>but worse</span></li>
          </ul>
        </section>

        <section>
          <h2>Index (A,B,C)</h2>
        </section>

        <section>
          <h2><span class="green">&#10004;</span>Will use</h2>
          <ul>
            <li>ORDER BY A</li>
            <li>A=7 ORDER BY B</li>
            <li>ORDER BY A DESC, B DESC</li>
            <li>A>7 ORDER BY A</li>
          </ul>
        </section>

        <section>
          <h2><span class="red">&#10008;</span>Wont use</h2>
          <ul>
            <li>ORDER BY B</li>
            <li>A>7 ORDER BY B</li>
            <li class="red">A IN(1,2) ORDER BY B</li>
            <li>ORDER BY A ASC, B DESC</li>
          </ul>
        </section>

        <section>
          <h2>UNION trick</h2>
          <p>Consider breaking a query down and unioning for
          performance</p>
            <p>KEY(A,B)</p>
          <div class="fragment">
            <pre><code class="sql" data-trim >SELECT * FROM TBL WHERE A IN (1,2) ORDER BY B LIMIT 5;</code></pre>
            <p><small>Will not use index for sorting</small><p>
          </div>
          <pre class="fragment"><code class="sql" data-trim >(SELECT * FROM TBL WHERE A=1 ORDER BY B LIMIT 5)
UNION ALL
(SELECT * FROM TBL WHERE A=2 ORDER BY B LIMIT 5)
ORDER BY B LIMIT 5;</code></pre>
<small class="fragment">'filesort' required for 10 rows</small>
        </section>

        <section>
          <h2>Index Merge</h2>
          <ul>
            <li>SELECT id FROM some_table WHERE A=1 AND B=2;
              <br><small>INDEX(A,B)</small>
            </li>
            <li class="fragment">SELECT id FROM some_table WHERE A=1 OR B=2;
              <br><small>INDEX(A), INDEX(B)</small>
            </li>
            <li class="fragment"><a href="http://dev.mysql.com/doc/refman/5.1/en/index-merge-optimization.html">Mysql manual reference</a></li>
          </ul>
        </section>

        <section>
          <h2>Table joins</h2>
          <ul>
            <li>Ensure all foreign keys are indexed</li>
            <ul>
              <li>Consider compound keys based on workload</li>
            </ul>
            <li class="fragment">Inner join > Left join</li>
            <li class="fragment">Unioned smaller inner joined queries > 1 huge left join</li>
          </ul>
        </section>

        <section>
          <h2>Index selection</h2>
          <ul>
            <li>Don't mess with the optimizer<br>
            It's <i>*usually*</i> right</li>
            <li>No index - Sometimes it's more trouble to access index than do
              full table scan</li>
          </ul>
        </section>

        <section>
          <h2>Index structure tools</h2>
          <pre><code class="sql" data-trim >DESCRIBE mydatabase.sometable;</code></pre>
          <pre><code class="sql" data-trim >SHOW INDEX FROM mydatabase.sometable;</code></pre>
          <pre><code class="sql" data-trim >ALTER TABLE mydatabase.sometable ADD INDEX myindexname</code></pre>
          <pre><code class="sql" data-trim >ALTER [IGNORE] TABLE tbl_name
    [alter_specification [, alter_specification] ...]

alter_specification:
    table_options
  | ADD {INDEX|KEY} [index_name]
        [index_type] (index_col_name,...) [index_type]
  | ADD [CONSTRAINT [symbol]]
        UNIQUE [INDEX|KEY] [index_name]
        [index_type] (index_col_name,...) [index_type]
  | DROP {INDEX|KEY} index_name

index_col_name:
    col_name [(length)] [ASC | DESC]</code></pre>
        </section>

        <section>
          <h2>Index structure tools (cont.)</h2>
          <pre><code class="sql" data-trim >root, presentation> SHOW INDEXES FROM fakenames_full;
+----------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table          | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+----------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| fakenames_full |          0 | PRIMARY  |            1 | id          | A         |     1006230 |     NULL | NULL   |      | BTREE      |         |               |
| fakenames_full |          1 | dob      |            1 | dob         | A         |       47915 |     NULL | NULL   | YES  | BTREE      |         |               |
| fakenames_full |          1 | State    |            1 | State       | A         |          18 |     NULL | NULL   |      | BTREE      |         |               |
| fakenames_full |          1 | State    |            2 | ZipCode     | A         |        2211 |     NULL | NULL   |      | BTREE      |         |               |
| fakenames_full |          1 | dob_year |            1 | dob_year    | A         |         273 |     NULL | NULL   | YES  | BTREE      |         |               |
| fakenames_full |          1 | Surname  |            1 | Surname     | A         |       11305 |     NULL | NULL   |      | BTREE      |         |               |
+----------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
6 rows in set (0.04 sec)</code></pre>
        </section>

        <section>
          <h2>Explains shortcomings</h2>
          <pre><code class="sql" data-trim >EXPLAIN SELECT * FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra       |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+-------------+</code></pre>

          <pre><code class="sql" data-trim >EXPLAIN SELECT state FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
| id | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows | Extra                    |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+
|  1 | SIMPLE      | fakenames_full | range | State         | State | 604     | NULL | 3804 | Using where; Using index |
+----+-------------+----------------+-------+---------------+-------+---------+------+------+--------------------------+</code></pre>
          <h3>Which one is quantifiably better?</h3>
        </section>

        <section>
          <h3>PROFILE</h3>
          <pre><code class="sql" data-trim >SELECT @@profiling;
SET profiling=1;
SELECT * FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
SELECT state FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540';
SET profiling=0;

SHOW PROFILES;
+----------+------------+------------------------------------------------------------------------------------------------------------------+
| Query_ID | Duration   | Query                                                                                                            |
+----------+------------+------------------------------------------------------------------------------------------------------------------+
|        1 | 0.16900075 | SELECT * FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540'     |
|        2 | 0.00304075 | SELECT state FROM fakenames_full WHERE state IN('NSW','ACT','NT','QLD','SA','TAS','VIC','WA') AND zipcode='2540' |
+----------+------------+------------------------------------------------------------------------------------------------------------------+
2 rows in set (0.01 sec)
</code></pre>
        </section>

        <section>
          <h3>PROFILE (cont.)</h3>
          <pre><code class="sql" data-trim >root, presentation>SHOW PROFILE;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000031 |
| Waiting for query cache lock   | 0.000008 |
| checking query cache for query | 0.000053 |
| checking permissions           | 0.000011 |
| Opening tables                 | 0.000024 |
| System lock                    | 0.000013 |
| Waiting for query cache lock   | 0.000025 |
| init                           | 0.000030 |
| optimizing                     | 0.000016 |
| statistics                     | 0.000149 |
| preparing                      | 0.000018 |
| executing                      | 0.000008 |
| Sending data                   | 0.001164 |
| Waiting for query cache lock   | 0.000018 |
| Sending data                   | 0.001261 |
| end                            | 0.000032 |
| query end                      | 0.000016 |
| closing tables                 | 0.000025 |
| freeing items                  | 0.000023 |
| Waiting for query cache lock   | 0.000016 |
| freeing items                  | 0.000061 |
| Waiting for query cache lock   | 0.000010 |
| freeing items                  | 0.000007 |
| storing result in query cache  | 0.000010 |
| logging slow query             | 0.000007 |
| cleaning up                    | 0.000008 |
+--------------------------------+----------+
26 rows in set (0.01 sec)</code></pre>

<pre><code class="sql" data-trim >SHOW PROFILE FOR QUERY 1;
SHOW PROFILE [ALL | BLOCK IO | CONTEXT SWITCHES | CPU | IPC | MEMORY | PAGE FAULTS | SOURCE | SWAPS] FOR QUERY 1;</code></pre>
        </section>

        <section>
          <h2>The pager</h2>
          <pre><code class="sql" data-trim >pager less
SELECT * FROM fakenames_full LIMIT 10000;
nopager</code></pre>
          <h2>pt-visual-explain</h2>
          <h5>Installation (Ubuntu)</h5>
          <pre><code class="shell" data-trim >wget percona.com/get/percona-toolkit.deb
sudo apt-get install libterm-readkey-perl
sudo dpkg -i percona-toolkit.deb</code></pre>
          <h5>Usage</h5>
          <pre><code class="sql" data-trim >pager pt-visual-explain
EXPLAIN SELECT * FROM fakenames_full LIMIT 10000;
nopager
          </code></pre>
          <small><a href="http://www.mysqlperformanceblog.com/2008/06/23/neat-tricks-for-the-mysql-command-line-pager">Original article</a></small>
          <aside class="notes">
              Less -> navigation, search, highlight, save as
          </aside>
        </section>

        <section>
          <h2>Andrie's rules</h2>
          <ul>
            <li>Remember the rules</li>
            <li>Understand the rules</li>
            <li>Break the rules when necessary</li>
            <li class="fragment"><span class="green">(Except Stuarts #1 and #2)</span></li>
          </ul>
        </section>

	<section>
	  <h1>THE END</h1>
	  <h3>Thank you</h3>
	</section>

      </div>

    </div>

    <script src="reveal/lib/js/head.min.js"></script>
    <script src="reveal/js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,
      width: 1200,
      theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

      // Optional libraries used to extend on reveal.js
      dependencies: [
      { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
      // { src: 'reveal/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
      // { src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
      ]
      });

    </script>

  </body>
</html>
